<html xmlns:MSHelp="http://msdn.microsoft.com/mshelp" xmlns:msxsl="urn:schemas-microsoft-com:xslt" xmlns:xanx="http://schemas.microsoft.com/developer/xanx/2005"><head><META http-equiv="Content-Type" content="text/html; charset=utf-8"><META NAME="save" CONTENT="history"><title>Chasing and Evading Sample</title>
<style><!--
/***********************************************************
 *             SCRIPT-SUPPORTING STYLES
 ***********************************************************/

/* Defines the userData cache persistence mechanism. */
.userDataStyle
{
	behavior: url(#default#userData);
}

/* Used to save the scroll bar position when navigating away from a page. */
div.saveHistory
{
	behavior: url(#default#saveHistory);
}

/* Formats the expand/collapse images for all collapsible regions. */
img.toggle
{
	border: 0;
	margin-right: 5;
}

/* Formats the Language filter drop-down image. */
img#languageFilterImage
{
	border: 0;
	margin-left: 0;
	vertical-align: middle;
}

/* Formats the Members Options filter drop-down image. */
img#membersOptionsFilterImage
{
	border: 0;
	margin-left: 0;
	vertical-align: middle;
}

/* Formats the Collapse All/Expand All images. */
img#toggleAllImage
{
	margin-left: 0;
	vertical-align: middle;
}

/* Supports XLinks */
MSHelp\:link
{
 	text-decoration: underline;
	color: #0000ff; 
	hoverColor: #3366ff;
	filterString: ;
}


body
	{
	background:	#FFFFFF;
	color: #000000;
	font-family:	Verdana;
	font-size: medium;
	font-style: normal;
	font-weight: normal;
	margin-top:	0;
	margin-bottom:	0;
	margin-left:	0;
	margin-right:	0;
	width:	100%;
	/*font-size: 110%;*/
	}

div.section
	{
	margin-left: 15px;
	}

div.hxnx5
	{
	margin-left: 1.5em;
	}

/* Font for all headings */	
h1, h2, h3, h4, h5, h6
	{
	font-family: Verdana, Arial, Helvetica, sans-serif;
	margin-top: 18;
	margin-bottom: 8; 
	font-weight: bold;
	}
h1
	{
	font-size: 130%;
	color: #003399;
	}
div#scrollyes h1 /* Changes font size for full-scrolling topic */
	{
	font-size: 150%;
	}
h2
	{
	font-size: 125%;
	}
h3
	{
	font-size: 115%;
	margin-top: 9;
	margin-bottom: 4; 
	}
h4
	{
	font-size: 115%;
	margin-top: 9;
	margin-bottom: 4; 
	}
h5
	{
	font-size: 100%;
	margin-top: 9;
	margin-bottom: 4; 
	}
h6
	{
	font-size: 100%;
	margin-top: 9;
	margin-bottom: 4; 
	}

ul p, ol p, dl p
	{
	margin-left: 0em;
	}

p
	{
	margin-top: .6em;
	margin-bottom: .6em;
	}
	
td p
	{
	margin-top: 0.0em;
	margin-bottom: 0.6em;
	}

dd p
	{
	margin-top: 0.0em;
	margin-bottom: 0.6em;
	}

.image
	{
	text-align: center;
	}

dl
	{
	margin-top: 0em; 
	margin-bottom: 1.3em;
	}

dd
	{
	margin-bottom: 0em;
	margin-left: 0;
	}

dl.glossary dd 
{
	margin-bottom: 0em;  
	margin-left: 1.5em; 
}

dt
	{
	margin-top: .6em;
	margin-bottom: 1;
	}

ul, ol
	{
	margin-top: 0.6em;
	margin-bottom: 0.6em; 	
	}
	
ol
	{
	margin-left: 2.5em; 
	
	}	
	
ul
	{
	list-style-type: disc; 
	margin-left: 1.9em; 
	}

li
	{
	margin-bottom: 0.4em;
	}

ul ol, ol ol
	{
	list-style-type: lower-alpha;
	}

pre
	{
	margin-top: .6em;
	margin-bottom: .6em; 
	}

pre
	{
	font: 105% Lucida, mono; 
	color: #000066;
	}

code
{
	font-family: Monospace, Courier New, Courier;
	font-size: 105%;
	color:	#000066;
}

table.userdata td 
	{
	background: #ffffff;
	background-color: #F5F5F5;
	border-color: #ffffff;
	border: none;
	}	
table.clsWarning
	{
	background: #ffffff;
	padding: 0px;
	margin: 0px;
	border: none;
	}
table.clsWarning td
	{
	padding: 0px;
	margin: 0px;
	background: #ffffff;
	vertical-align: middle;
	font-size: 70%;
	}

div#mainSection table
	{
	width: 98%;
	background: #ffffff;
	margin-top: 5px;
	margin-bottom: 5px;
	}

div#mainSection table th
	{ 
	padding: 5px 6px;
	background: #EFEFF7;
	text-align: left;
	font-size: 70%;
	vertical-align: bottom;
	border-bottom: 1px solid #C8CDDE;
	}
div#mainSection table td
	{ 
	padding: 5px 5px;
	background: #F7F7FF;
	vertical-align: top;
	font-size: 70%;
	border-bottom: 1px solid #D5D5D3;
	}

div#syntaxCodeBlocks table th
	{
	padding: 1px 6px;
	color: #000066;
	}

div#syntaxCodeBlocks table td
	{
	padding: 1px 5px;
	}

/* Applies to the running header text in the first row of the upper table in the
   non-scrolling header region. */
span#runningHeaderText
{
	color: #003399;
	font-size: 90%;
	padding-left: 13;
}

/* Applies to the topic title in the second row of the upper table in the
   non-scrolling header region. */
span#nsrTitle
{
	color: #003399;
	font-size: 120%;
	font-weight: 600;
	padding-left: 13;
}

/* Applies to everything below the non-scrolling header region. */
div#mainSection
{
	font-size: 70%;
	width: 100%;
}

/* Applies to everything below the non-scrolling header region, minus the footer. */
div#mainBody
{
	font-size: 90%;
	margin-left: 15;
	margin-top: 10;
	padding-bottom: 20;
}

/* Adds right padding for all blocks in mainBody */
div#mainBody p, div#mainBody ol, div#mainBody ul, div#mainBody dl
{
	padding-right: 5;
}

div#mainBody div.alert, div#mainBody div.code, div#mainBody div.tableSection
{
	width:98.9%;
}

div.alert p, div.code p
{
	margin-top:5;
	margin-bottom:8;
}

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Begin Note Styles - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
div#mainSection div.alert table
{
	border: 0;
}

div#mainSection div.alert table th
{
	padding-top: 0;
	padding-bottom: 0;
	padding-left: 5;
	padding-right: 5;
}

div#mainSection div.alert table td
{
	padding-left: 5;
	padding-right: 5;
}

img.note
{
	border: 0;
	margin-left: 0;
	margin-right: 3;
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - End Note Styles - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Begin Non-scrolling Header Region Styles - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* Applies to the entire non-scrolling header region. */
div#header
{
	background-color: #D4DFFF;
	padding-top:	0;
	padding-bottom:	0;
	padding-left:	0;
	padding-right:	0;
	width:	100%;
}

/* Applies to both tables in the non-scrolling header region. */
div#header table
{
	margin-top:	0;
	margin-bottom: 0;
	border-bottom-color: #C8CDDE;
	border-bottom-style: solid;
	border-bottom-width: 1;
	background: #D4DFFF;
	width:	100%;
}

/* Applies to cells in both tables in the non-scrolling header region. */
div#header table td
{
	color: #0000FF;
	font-size: 70%;
	padding-right: 20;
	padding-top: 1;
	padding-bottom: 1;
	border: none;
	background: #D4DFFF;
}

/* Applies to the last row in the upper table of the non-scrolling header region. Text 
   in this row includes See Also, Constructors, Methods, and Properties. */
div#header table tr#headerTableRow3 td
{
	padding-bottom: 2;
	padding-top: 5;
	padding-left: 15;
}

/* Applies to the lower table in the non-scrolling header region. Text in this table
   includes Collapse All/Expand All, Language Filter, and Members Options. */
div#header table#bottomTable
{
	border-top-color: #FFFFFF;
	border-top-style: solid;
	border-top-width: 1;
	text-align: left;
	padding-left: 15;
}


blockquote
	{
	margin-left: 3.8em;
	margin-right: 3.8em;
	margin-top: .6em;
	margin-bottom: .6em;
	}

sup
	{
	text-decoration: none;
	font-size: smaller; 
	}

a:link
	{
	color: #0000FF;
/*    font-weight: bold */
	}
	
a:visited
	{
	color: #0000AA;
/*    font-weight: bold	*/
	}
	
a:hover
	{
	color: #3366FF;
/*    font-weight: bold */
	}
	
.label
	{
	font-weight: bold; 
	margin-top: 1em;
	margin-left: -26px;
	}
	
.tl
	{
	margin-bottom: .75em; 
	}
	
.atl
	{
	padding-left: 1.5em;
	padding-bottom: .75em; 
	}
	
.cfe
	{
	font-weight: bold; 
	}
	
.mini
	{
	font-size: smaller;
	}
	
.dt
	{
	margin-bottom: -.6em; 
	}
	
.indent
	{
	margin-left: 1.9em; 
	margin-right: 1.9em;
	}

.product
	{
	text-align: right;
	color: #333333;
	font-size: smaller;
	font-style: italic;
	}

.buttonbarshade
	{
	position: relative;
	margin: 0;
	left: 0px;
	top: 2;
	width: 50%;
	height: 40px;
	}

.buttonbartable
	{
	position: absolute;
	margin: 0;
	padding:0;
	border:0;
	left:0px;
	top: 2;
	width: 100%;
	height: 40px;
	}

/* background color, font for header */ 
table.buttonbartable td, table.buttonbarshade td
	{
	background: #ffffff; /*#5177B8; #80C615;*/
	border-left: 0px solid #80C615;
	margin: 0;
	padding: 0px 0px 0px 0px;
	font-family: Impact, sans-serif;
	font-size: 14pt;
	}

table.buttonbartable td.button1
	{
	background: #5177B8; /*#80C615;*/;
	padding: 0;
	font-weight: bold;
	text-align: center;
	cursor: hand;
	}

table.buttonbartable td.button2
	{
	background: #5177B8; /*#80C615;*/;
	font-weight: bold;
	text-align: center;
	}

table.buttonbartable td.button3
	{
	background: #5177B8; /*#80C615;*/;
	font-weight: bold;
	text-align: center;
	}

table.buttonbartable td.runninghead
	{
	padding-left: 0px;
	font-style: italic;
	text-align: left;
	}

.version
	{
	text-align: left;
	color: #000000;
	margin-top: 3em;
	margin-left: -26px;
	font-size: smaller;
	font-style: italic;
	}

.lang, .ilang
	{
	color: #0000ff;
	font: normal 7pt Arial, Helvetica, sans-serif;
	}

div.langMenu
	{
	position: absolute;
	z-index: 1;
	width: 96pt;
	padding: 8pt;
	visibility: hidden;
	border: 1px solid #000000;
	background: #ffffd0;
	}

div.langMenu ul
	{
	padding-left: 2em;
	margin-left: 0;
	}

div.filtered
	{
	margin: 4pt 0 8pt -26px;
	padding: 4px 4px 8px 26px;
	width: 100%;
	border: 2px solid #aaaacc;
	background: #ffffff;
	}

div.filtered2
	{
	margin: 4pt 0 8pt -26px;
	padding: 4px 4px 8px 26px;
	width: 100%;
	border: none;
	background: #ffffff;
	}

div.filtered h1, div.filtered h2, div.filtered h3, div.filtered h4
	{
	margin-left: -22px;
	}

div.filtered span.lang
	{
	position: relative;
	left: -22px;
	}

div.reftip
	{
	position: absolute;
	z-index: 1;
	padding: 8pt;
	visibility: hidden;
	border: 1px solid #000000;
	background: #ffffd0;
	}

a.synParam
	{
	color: #0000FF;
	/*color: #3F7800;*/ 	
	/*color: #8DC54F;*/
	text-decoration: none;
    font-weight: normal;
	}

a.synParam:hover
	{
	text-decoration: underline;
    font-weight: normal;
	}

div.sapop
	{
	position: absolute;
	z-index: 1;
	left: 26px;
	width: 100%;
	padding: 10px 10px 10px 36px;
	visibility: hidden;
	border: 1px solid #000000;
	background: #ffffd0;
	}

div.footer
	{
	width: 100%;
	border: none;
	background: #ffffff;
	margin-top: 18pt;
	padding-bottom: 12pt;
	color: #0000FF;
	/*color: #228B22; */
	text-align: center;
	font-size: 76%;
	}

div.preliminary
	{
	margin-top: 8pt;
	padding-bottom: 12pt;
	color: #A0A0A0;
	}

/* A procedure section. eg. 'To create a file', 'To add a value' */
div.proc
    {
	margin-left: 0.5em; 
    }
     
/* The title of a 'procedure' section. */
div.proc h3
    {
	font-family: Verdana, Arial, Helvetica, sans-serif;
	font-weight: bold;
	font-size: 115%;
	margin-top: 1em;
	margin-bottom: 0.4em;
	margin-left: -0.5em; 
	color: #003399;
    }

div.proc ul
    {
    margin-left: 1.5em;
    }

div.proc ol
    {
    margin-left: 2.0em;
    }
      
.note
	{
	margin-left: 14pt;
	margin-right: 12pt;
	}

.indent1
	{
	margin-left: 12pt;
	}

.indent2
	{
	margin-left: 24pt;
	}

.indent3
	{
	margin-left: 36pt;
	}

p.proch
	{
	padding-left: 16px;
	}

p.proch img
	{
	position: relative; 
	vertical-align: top;
	left: -18px; 
	margin-right: -14px; 
	margin-bottom: -18px;
	}
	
div.clsPlatSpec
{
	background-color:#FFF8DC;
	border-style:solid;
	border-width:1pt 0pt 0pt 1pt;
	border-color:#ffE4C4;
	margin-top:0.6em;
	width:100%;
}


/* Applies to the language labels in the Language Filter drop-down list. */
.languageFilter
{
	color:	#0000FF;
	cursor:hand;
	text-decoration:underline;
	padding-bottom:4;
}

/* Dropdown areas */

#languageSpan {
	position: absolute;
	visibility: hidden;
	border-style: solid;
	border-width: 1px;
	border-color: #C8CDDE;
	background: #d4dfff;
	padding: 4px;
	font-size: 70%;
}

#membersOptionsSpan {
	position: absolute;
	visibility: hidden;
	border-style: solid;
	border-width: 1px;
	border-color: #C8CDDE;
	background: #d4dfff;
	padding: 4px;
	font-size: 70%;
}
--></style>

<xml>
<MSHelp:TOCTitle Title="Chasing and Evading Sample" />
<MSHelp:RLTitle Title="Chasing and Evading Sample" />
<MSHelp:Keyword Index="A" Term="O:Microsoft.Xna.ChaseAndEvade" />
<MSHelp:Keyword Index="A" Term="24467413-eb62-e61e-e91a-ff6f4faa0fac" />
<MSHelp:Keyword Index="K" Term="Chasing and Evading Sample" />
<MSHelp:Attr Name="ProjType" Value="LocalProj" />
<MSHelp:Attr Name="ProjType" Value="XNA_20" />
<MSHelp:Attr Name="DocSet" Value="XNA" />
<MSHelp:Attr Name="DocSet" Value="ExpressLibVS" />
<MSHelp:Attr Name="DocSet" Value="C#" />
<MSHelp:Attr Name="Locale" Value="en-us" />
<MSHelp:Attr Name="AssetID" Value="24467413-eb62-e61e-e91a-ff6f4faa0fac" />
<MSHelp:Attr Name="TopicType" Value="kbOrient" />
</xml>
</head><body><div id="mainSection"><div id="mainBody">

  <h1>Chasing and Evading Sample</h1>

  
    This sample shows how to implement several simple behaviors for AI, including chasing, evading, and
    wandering.
  
  <a name="ID2EK"></a><h1 class="heading">Sample Overview</h1><div id="ID2EK" class="hxnx1">
    
    <p>
      This sample demonstrates chase and evade behaviors by using three actors—a cat, a mouse, and a tank. The tank and the
      mouse are controlled by AI, and the cat is controlled by the player. The tank chases the cat, and the mouse
      runs from the cat. The tank and the mouse wander around the screen when the cat is not nearby. The
      "turn toward" functionality from the "AI Series 1: Aiming" sample makes it very simple to create these behaviors—chase, evade, and wander—very simple.
    </p>
    <a name="ID2EX"></a><h2 class="subHeading">Minimum Shader Profile</h2><div id="ID2EX" class="hxnx2">
      
      <dl class="glossary">
        <dt>Vertex Shader Model 1.1</dt>
        <dt>Pixel Shader Model 1.1</dt>
      </dl>
    </div>
    <a name="ID2EDB"></a><h2 class="subHeading">Sample Controls</h2><div id="ID2EDB" class="hxnx2">
      
      <p>This sample uses the following keyboard and gamepad controls.</p>
      <table>
        <tr>
          <th>Action</th>
          <th>Keyboard Control</th>
          <th>Gamepad Control</th>
        </tr>
        <tr>
          <td>Move the cat.</td>
          <td>UP ARROW, DOWN ARROW, LEFT ARROW, and RIGHT ARROW</td>
          <td>Left thumb stick, D-Pad</td>
        </tr>
        <tr>
          <td>Exit the sample.</td>
          <td>ESC or ALT+F4</td>
          <td>
            <b>BACK</b>
          </td>
        </tr>
      </table>
    </div>
  </div>

  <a name="ID2EMC"></a><h1 class="heading">How the Sample Works</h1><div id="ID2EMC" class="hxnx1">
    
    <a name="ID2EQC"></a><h2 class="subHeading">Chase</h2><div id="ID2EQC" class="hxnx2">
      
      <p>
        The sample first introduces chase behavior. How does it work? In the first sample
        of this series, we saw how to make one object turn toward another by using the method <b>TurnToFace</b>.
        This method makes it very easy to make the tank chase the cat—all we have to do is make the tank
        <b>TurnToFace</b> the cat, and then move forward.
      </p>
    </div>
    <a name="ID2E5C"></a><h2 class="subHeading">Evade</h2><div id="ID2E5C" class="hxnx2">
      
      <p>
        The evade behavior is similar to the chase behavior. An object turns away from the target, instead of turning toward the target. If we make the mouse turn away from the cat and move forward, the
        mouse evades the cat. Simple enough—but the <b>TurnToFace</b> method takes a point to turn toward,
        not a point to turn away from. So, to what point do we make the mouse turn toward?
      </p>
      <img src="Documentation/EvadeDiagram.png">
      <p>
        This diagram shows the cat and the mouse. The position of the mouse is represented by the vector
        <i>mousePosition</i>, and the position of the cat is represented by the vector <i>
        catPosition.</i>
        We can see that if the mouse turns towards the point marked <i>
        seekPosition</i>, it then turns away from
        the cat. We can use the <i>
        catToMouse</i> vector to find <i>
        seekPosition</i>:
      
    </p>
      <dl class="glossary">
        <dd><i>seekPosition</i> = <i>mousePosition</i> + <i>catToMouse</i>
        </dd>
      </dl>
      <p>
        The catToMouse vector is actually just <i>mousePosition</i> - <i>catPosition</i>,
        which we can substitute in the above equation. This gives us the following:
      </p>
      <dl class="glossary">
        <dd><i>seekPosition</i> = <i>mousePosition</i> + (<i>mousePosition</i> - <i>catPosition</i>)</dd>
      </dl>
      <dl class="glossary">
        <dd><i>seekPosition</i> = 2 * <i>mousePosition</i> - <i>catPosition</i>
        </dd>
      </dl>
      <p>To make the mouse evade the cat, we use this equation to calculate <i>seekPosition</i>.
      The mouse then moves toward <i>seekPosition</i> and away from the cat.
      </p>
    </div>
    <a name="ID2ELF"></a><h2 class="subHeading">Wander</h2><div id="ID2ELF" class="hxnx2">
      
      <p>
        The wander behavior uses a vector called <i>wanderDirection</i> for each character.
        In every frame, <i>wanderDirection</i> is slightly modified. When a character wanders, it turns so that it faces
        toward <i>wanderDirection</i>.
        </p>
      <p>
        To keep the characters at the center of the screen, you can also make characters turn to face the
        screen center. The <b>Wander</b> method calculates a variable called <i>turnToCenterSpeed</i>. This calculation determines how much
        the characters will turn towards the center of the screen. This variable is based on the distance of the character from the center of the screen. The farther a character is from the screen center, the more it aims back toward the center.
      </p>
      <p>
        To do this, first we calculate <i>normalizedDistance</i>, which varies from 0 to 1 depending on how far
        the character is from <i>screenCenter</i>. The <i>turnToCenterSpeed</i> variable is .3 * <i>normalizedDistance</i> *
        <i>normalizedDistance</i> * <i>turnSpeed</i>. By squaring <i>normalizedDistance</i>,
        we get a smooth response curve. Near the center of the screen, a character does not turn very much. However, toward the outer edge of the screen, it turns much more sharply. The <i>turnSpeed</i> variable is the character's <i>maximumTurnSpeed</i>, and .3 is simply a constant that was found
        by experimentation. The constant .3 seems to work well for this sample, but feel free to play with it for different results.
        Smaller values will make the characters explore further from the center, but the characters may get stuck at the edges. Larger numbers
        will hold the characters to the center of the screen. If the number is too large, the characters may end up orbiting the center.
      </p>
    </div>
    <a name="ID2EVG"></a><h2 class="subHeading">Movement</h2><div id="ID2EVG" class="hxnx2">
      
      <p>
        All the behaviors in this sample are created by turning toward some point and then moving forward.
        The <code>TurnToFace</code> method can be used to turn towards a point, but how do we move forward? The direction the characters face is stored as an angle. How do we use this angle to change the x and y components of the character's positions?
        In other words, how can we convert from a heading <i>angle</i> to a heading <i>vector</i>?
      </p>
      <p>
        Trigonometry to the rescue again. Don't cringe, though—this is actually very straightforward. Trigonometry has a concept of a
        unit circle, which is a circle that has a radius of 1. The cosine and sine functions that we all know and love
        are defined as x and y coordinates on the unit circle.
      </p>
      <img src="Documentation/UnitCircle.png">
      <p>
        In this diagram, the blue line goes from (0,0) to a point on the unit circle, and makes an angle of θ with the positive x axis.
        The coordinates of the point where the unit circle intersects the blue line are (cosine(θ), sine(θ)).
      </p>
      <p>
        So, what does this tell us? Remember, we're trying to find a vector ( x, y coordinates ) from an angle. Well, now it's easy:
      </p>
      <div class="code"><span codeLanguage="CSharp"><table><tr><th>C# </th></tr><tr><td><pre><pre>
Vector2 headingVector = new Vector2((float)Math.Cos(headingAngle), (float)Math.Sin(headingAngle));
      </pre></pre></td></tr></table></span></div>
      <p>To find a heading vector, all we have to do is take the sin and cosine of the heading angle.</p>
    </div>
    <a name="ID2EUH"></a><h2 class="subHeading">Hysteresis</h2><div id="ID2EUH" class="hxnx2">
      
      <p>
        One common problem in game programming—particularly AI programming—is hysteresis. The following text, from <a href="http://blogs.msdn.com/shawnhar/archive/2007/04/23/hysteresis.aspx">Shawn Hargreaves's blog</a>, explains the problem very well.
      </p>
      <a name="ID2EDAAC"></a><h4 class="subHeading">Sorting Out the Complexity</h4><div id="ID2EDAAC" class="hxnx3">
        
        <p>
          Games often have to make discrete decisions based on continuously varying analog input values, as in the following:
        </p>
        <div class="code"><span codeLanguage="CSharp"><table><tr><th>C# </th></tr><tr><td><pre><pre>
if (health &gt; 0.5)
  AttackEnemy();
else
  RunAway();
        </pre></pre></td></tr></table></span></div>
        <p>
          This sort of thing happens frequently. Games are complex simulations that contain a lot of chaotically
          varying information. Often they need to examine the simulation state and make decisions based on specific values.
        </p>
        <p>
          Game simulations tend to produce a lot of small and basically random fluctuations from one frame to
          the next. When these values are used to control a discrete decision, and when the input value is close to the decision
          threshold, the results can look pretty silly. For example, an AI character might decide to attack you, only to change its mind on
          the next frame and run away, only to heal slightly and decide to attack you again, with the end result that the character just spins
          in a circle.
        </p>
        <p>
          The solution is to add hysteresis in your decision making code. Any time you find yourself making a Boolean decision by
          testing a floating point value:
        </p>
        <div class="code"><span codeLanguage="CSharp"><table><tr><th>C# </th></tr><tr><td><pre><pre>
if (inputValue &gt; threshold)
    DoSomething();
else
    OtherThing();
        </pre></pre></td></tr></table></span></div>
        <p>you should think about including a hysteresis region:</p>
        <div class="code"><span codeLanguage="CSharp"><table><tr><th>C# </th></tr><tr><td><pre><pre>
const float hysteresisAmount = 0.1;

if (inputValue &gt; threshold + hysteresisAmount)
    DoSomething();
else if (inputValue &lt; threshold - hysteresisAmount)
    OtherThing();
else
    KeepOnDoingWhateverYouAlreadyAre();
        </pre></pre></td></tr></table></span></div>
        <p>
          This prevents tiny fluctuations from causing unwanted flickering in the decision result. If the input value is significantly
          above or below the decision threshold, the game will change state. However, when the input is near the threshold, it just keeps on doing
          whatever it had previously decided.
        </p>
      </div>
      <p>This concept is used in two different ways in this sample—once for the AI for the mouse, and once for the AI for the tank.</p>
    </div>
    <a name="ID2EGBAC"></a><h2 class="subHeading">Mouse AI</h2><div id="ID2EGBAC" class="hxnx2">
      
      <p>
        The goal is to make the mouse evade the cat when the mouse gets too close to the cat, and wander around the screen when it feels safe. We already
        know how to implement the evade and wander behaviors. Deciding which behavior for the mouse to perform, based on its distance from the cat, seems
        simple enough. In psuedocode, it looks like the following:
      </p>
      <div class="code"><span codeLanguage="CSharp"><table><tr><th>C# </th></tr><tr><td><pre><pre>
if (distanceFromCat &gt; MouseEvadeDistance )
{
    wander
}
else
{
    evade
}
      </pre></pre></td></tr></table></span></div>
      <p>
        If the distance from the cat is near the threshold, however, the mouse "flickers" between wander and evade. We have to
        use a hysteresis constant.
      </p>
      <div class="code"><span codeLanguage="CSharp"><table><tr><th>C# </th></tr><tr><td><pre><pre>
float distanceFromCat = Vector2.Distance(mousePosition, catPosition);

if (distanceFromCat &gt; MouseEvadeDistance + MouseHysteresis)
{                
    mouseState = MouseAiState.Wander;
}
else if (distanceFromCat &lt; MouseEvadeDistance - MouseHysteresis)
{
    mouseState = MouseAiState.Evading;
}
      </pre></pre></td></tr></table></span></div>
      <p>
        In order to implement the "keep doing what you were doing before" part of hysteresis, we keep track of what the mouse is currently
        doing by using an enumeration called <b>MouseAiState</b>. We use a variable called <i>mouseState</i>, of type <b>MouseAiState</b>, and to change what
        the mouse is currently doing, we can change the value of <i>mouseState</i>. The end result is that the mouse behavior follows a pattern something like the following:
      </p>
      <img src="Documentation/MouseAI.png">
      <p>
        As the distance from the cat increases, the mouse moves from the evade state to the wander state. If the distance from the cat
        is in the orange region marked "no change," the mouse continues doing whatever it was last doing.
      </p>
      <p>
        Now that we have decided the states that the mouse should be in, all that's left is to implement the states. The
        techniques that are described in this document make this work straightforward.
      </p>
    </div>
    <a name="ID2EKCAC"></a><h2 class="subHeading">Tank AI</h2><div id="ID2EKCAC" class="hxnx2">
      
      <p>
        Our goal is to make the tank chase the cat. If the tank gets close enough to the cat, it considers the chase
        finished, and stops. If the cat gets too far away, the tank gives up the chase, and wanders around. This gives us a total of
        three different things the tank do—it can wander, it can chase, or it can stop.
      </p>
      <p>
        The mouse AI had only two states involved in its decision making process—evade and wander. This made the code fairly simple—just an <b>if-else</b>. Unfortunately, this doesn't work for the tank AI. We need to use a different implementation of hysteresis.
        The tank AI follows a pattern like the following:
      </p>
      <img src="Documentation/TankAI.png">
      <p>
        In this diagram, there are the three states that we expect to see—caught, chase, and wander. What is interesting is the regions in the middle.
        This is another way of implementing hysteresis. In this method, the thresholds for changing state move, depending on the current state.
        For example, if the tank is in the caught region, it stays in the caught stage until the distance from the cat is greater than 
        <i>TankCaughtDistance</i> + <i>TankHysteresis</i>. However, after the tank switches to the chase stage, the caught/chase
        threshold moves to the left, and the tank is more likely to stay in the chase stage. This lets us account for small fluctuations, as in the
        hysteresis method described above, but it also allows for slightly more complicated behavior.
      </p>
    </div>
  </div>
  <a name="ID2EKDAC"></a><h1 class="heading">Extending the Sample</h1><div id="ID2EKDAC" class="hxnx1">
    
    <p>
      Try making the cat behave on its own, instead of being controlled by the player. You might also try making the cat chase the mouse
      and evade the tank. The cat could decide which behavior is more important, based on its distance from each of the two other actors.
    </p>
  </div>
</div><div class="footer" id="footer"><p>© 2010 Microsoft Corporation. All rights reserved.<br>Send feedback to <a href="mailto:xnags@microsoft.com?subject=Documentation Feedback: Chasing and Evading Sample">xnags@microsoft.com</a>.</p></div></div></body></html>